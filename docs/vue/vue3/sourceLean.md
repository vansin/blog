# Vue3源码剖析

[拉钩教育课程笔记](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=946#/detail/pc?id=7630)
- 模块一：直击 Vue.js 核心组件的实现
  - 01 | 组件渲染：vnode 到真实 DOM 是如何转变的？
  - 02 | 组件更新：完整的 DOM diff 流程是怎样的？（上）
  - 03 | 组件更新：完整的 DOM diff 流程是怎样的？（下）
- 模块二：学会新设计 Composition API
  - 模块二导读 | 逻辑复用最佳实践：Composition API
  - 04 | Setup：组件渲染前的初始化过程是怎样的？
  - 05 | 响应式：响应式内部的实现原理是怎样的？（上）
  - 06 | 响应式：响应式内部的实现原理是怎样的？（下）
  - 07 | 计算属性：计算属性比普通函数好在哪里？
  - 08 | 侦听器：侦听器的实现原理和使用场景是什么？（上）
  - 09 | 侦听器：侦听器的实现原理和使用场景是什么？（下）
  - 10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？
  - 11 | 依赖注入：子孙组件如何共享数据？
- 模块三：编译过程和背后的优化思想
  - 模块三导读 | 编译和优化：了解编译过程和背后的优化思想
  - 12 | 模板解析：构造 AST 的完整流程是怎样的？（上）
  - 13 | 模板解析：构造 AST 的完整流程是怎样的？（下）
  - 14 | AST 转换：AST 节点内部做了哪些转换？（上）
  - 15 | AST 转换：AST 节点内部做了哪些转换？（下）
  - 16 | 生成代码：AST 如何生成可运行的代码？（上）
  - 17 | 生成代码：AST 如何生成可运行的代码？（下）
- 模块四：探索更多实用特性背后的实现原理
  - 模块四导读 | 实用特性：探索更多实用特性背后的原理
  - 18 | Props：Props 的初始化和更新流程是怎样的？
  - 19 | 插槽：如何实现内容分发？
  - 20 | 指令：指令完整的生命周期是怎样的？
  - 21 | v-model：双向绑定到底是怎么实现的？
- 模块五：学习 Vue 内置组件的实现原理
  - 模块五导读 | 内置组件：学习 Vue 内置组件的实现原理
  - 22 | Teleport 组件：如何脱离当前组件渲染子组件？
  - 23 | KeepAlive 组件：如何让组件在内存中缓存和调度？
  - 24 | Transition 组件：过渡动画的实现原理是怎样的？（上）
  - 25 | Transition 组件：过渡动画的实现原理是怎样的？（下）
- 特别放送：研究 Vue 官方生态的实现原理
  - 特别放送导读 | 研究 Vue 官方生态的实现原理
  - 26 | Vue Router：如何实现一个前端路由？（上）
  - 27 | Vue Router：如何实现一个前端路由？（下）

## 计算属性

理解计算属性的工作机制，能明白计算属性嵌套场景代码的执行顺序  

计算属性的两大特点
- 延时计算
- 缓存

空间换时间的策略

compute API两种使用方式的实现

[源码链接](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/computed.ts源码链接)